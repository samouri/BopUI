// tslint:disable
/**
 * PostgREST API
 * standard public schema
 *
 * OpenAPI spec version: 7.0.0 (2b61a63)
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url'
import * as portableFetch from 'portable-fetch'
import { Configuration } from './runtime'

const BASE_PATH = 'http://0.0.0.0:3000'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration!: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name!: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface Events
 */
export interface Events {
  /**
   *
   * @type {number}
   * @memberof Events
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Events
   */
  eventType?: string
  /**
   *
   * @type {string}
   * @memberof Events
   */
  dateAdded?: string
  /**
   *
   * @type {number}
   * @memberof Events
   */
  userAdded?: number
}

/**
 *
 * @export
 * @interface Metadata
 */
export interface Metadata {
  /**
   * Note: This is a Primary Key.<pk/>
   * @type {number}
   * @memberof Metadata
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  youtubeId: string
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  youtubeTitle: string
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  artist?: string
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  thumbnailUrl?: string
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  album?: string
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  youtubeDuration?: string
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  dateAdded?: string
}

/**
 *
 * @export
 * @interface Playlists
 */
export interface Playlists {
  /**
   * Note: This is a Primary Key.<pk/>
   * @type {number}
   * @memberof Playlists
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Playlists
   */
  name: string
  /**
   * Note: This is a Foreign Key to `users.id`.<fk table='users' column='id'/>
   * @type {number}
   * @memberof Playlists
   */
  userAdded?: number
  /**
   *
   * @type {string}
   * @memberof Playlists
   */
  dateAdded?: string
}

/**
 *
 * @export
 * @interface Songs
 */
export interface Songs {
  /**
   * Note: This is a Primary Key.<pk/>
   * @type {number}
   * @memberof Songs
   */
  id: number
  /**
   * Note: This is a Foreign Key to `playlists.id`.<fk table='playlists' column='id'/>
   * @type {number}
   * @memberof Songs
   */
  playlistId: number
  /**
   * Note: This is a Foreign Key to `metadata.id`.<fk table='metadata' column='id'/>
   * @type {number}
   * @memberof Songs
   */
  metadataId?: number
  /**
   * Note: This is a Foreign Key to `users.id`.<fk table='users' column='id'/>
   * @type {number}
   * @memberof Songs
   */
  userAdded: number
  /**
   *
   * @type {string}
   * @memberof Songs
   */
  dateAdded?: string
}

/**
 *
 * @export
 * @interface Users
 */
export interface Users {
  /**
   * Note: This is a Primary Key.<pk/>
   * @type {number}
   * @memberof Users
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Users
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  password: string
}

/**
 *
 * @export
 * @interface Votes
 */
export interface Votes {
  /**
   * Note: This is a Primary Key.<pk/>
   * @type {number}
   * @memberof Votes
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Votes
   */
  dateAdded?: string
  /**
   * Note: This is a Foreign Key to `users.id`.<fk table='users' column='id'/>
   * @type {number}
   * @memberof Votes
   */
  userAdded: number
  /**
   * Note: This is a Foreign Key to `songs.id`.<fk table='songs' column='id'/>
   * @type {number}
   * @memberof Votes
   */
  songId: number
}

/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [eventType]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsGet(
      id?: string,
      eventType?: string,
      dateAdded?: string,
      userAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/events`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (eventType !== undefined) {
        localVarQueryParameter['event_type'] = eventType
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (range !== undefined && range !== null) {
        localVarHeaderParameter['Range'] = String(range)
      }

      if (rangeUnit !== undefined && rangeUnit !== null) {
        localVarHeaderParameter['Range-Unit'] = String(rangeUnit)
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [eventType]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsGet(
      id?: string,
      eventType?: string,
      dateAdded?: string,
      userAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Events>> {
      const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsGet(
        id,
        eventType,
        dateAdded,
        userAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [eventType]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsGet(
      id?: string,
      eventType?: string,
      dateAdded?: string,
      userAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ) {
      return EventsApiFp(configuration).eventsGet(
        id,
        eventType,
        dateAdded,
        userAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
  /**
   *
   * @param {string} [id]
   * @param {string} [eventType]
   * @param {string} [dateAdded]
   * @param {string} [userAdded]
   * @param {string} [select] Filtering Columns
   * @param {string} [order] Ordering
   * @param {string} [range] Limiting and Pagination
   * @param {string} [rangeUnit] Limiting and Pagination
   * @param {string} [offset] Limiting and Pagination
   * @param {string} [limit] Limiting and Pagination
   * @param {'count=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public eventsGet(
    id?: string,
    eventType?: string,
    dateAdded?: string,
    userAdded?: string,
    select?: string,
    order?: string,
    range?: string,
    rangeUnit?: string,
    offset?: string,
    limit?: string,
    prefer?: 'count=none',
    options?: any
  ) {
    return EventsApiFp(this.configuration).eventsGet(
      id,
      eventType,
      dateAdded,
      userAdded,
      select,
      order,
      range,
      rangeUnit,
      offset,
      limit,
      prefer,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * IntrospectionApi - fetch parameter creator
 * @export
 */
export const IntrospectionApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary OpenAPI description (this document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootGet(options: any = {}): FetchArgs {
      const localVarPath = `/`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * IntrospectionApi - functional programming interface
 * @export
 */
export const IntrospectionApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary OpenAPI description (this document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = IntrospectionApiFetchParamCreator(configuration).rootGet(options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * IntrospectionApi - factory interface
 * @export
 */
export const IntrospectionApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary OpenAPI description (this document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootGet(options?: any) {
      return IntrospectionApiFp(configuration).rootGet(options)(fetch, basePath)
    },
  }
}

/**
 * IntrospectionApi - object-oriented interface
 * @export
 * @class IntrospectionApi
 * @extends {BaseAPI}
 */
export class IntrospectionApi extends BaseAPI {
  /**
   *
   * @summary OpenAPI description (this document)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntrospectionApi
   */
  public rootGet(options?: any) {
    return IntrospectionApiFp(this.configuration).rootGet(options)(this.fetch, this.basePath)
  }
}

/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataDelete(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/metadata`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (youtubeId !== undefined) {
        localVarQueryParameter['youtube_id'] = youtubeId
      }

      if (youtubeTitle !== undefined) {
        localVarQueryParameter['youtube_title'] = youtubeTitle
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (artist !== undefined) {
        localVarQueryParameter['artist'] = artist
      }

      if (thumbnailUrl !== undefined) {
        localVarQueryParameter['thumbnail_url'] = thumbnailUrl
      }

      if (album !== undefined) {
        localVarQueryParameter['album'] = album
      }

      if (youtubeDuration !== undefined) {
        localVarQueryParameter['youtube_duration'] = youtubeDuration
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataGet(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/metadata`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (youtubeId !== undefined) {
        localVarQueryParameter['youtube_id'] = youtubeId
      }

      if (youtubeTitle !== undefined) {
        localVarQueryParameter['youtube_title'] = youtubeTitle
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (artist !== undefined) {
        localVarQueryParameter['artist'] = artist
      }

      if (thumbnailUrl !== undefined) {
        localVarQueryParameter['thumbnail_url'] = thumbnailUrl
      }

      if (album !== undefined) {
        localVarQueryParameter['album'] = album
      }

      if (youtubeDuration !== undefined) {
        localVarQueryParameter['youtube_duration'] = youtubeDuration
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (range !== undefined && range !== null) {
        localVarHeaderParameter['Range'] = String(range)
      }

      if (rangeUnit !== undefined && rangeUnit !== null) {
        localVarHeaderParameter['Range-Unit'] = String(rangeUnit)
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {Metadata} [metadata] metadata
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataPatch(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      metadata?: Metadata,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/metadata`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (youtubeId !== undefined) {
        localVarQueryParameter['youtube_id'] = youtubeId
      }

      if (youtubeTitle !== undefined) {
        localVarQueryParameter['youtube_title'] = youtubeTitle
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (artist !== undefined) {
        localVarQueryParameter['artist'] = artist
      }

      if (thumbnailUrl !== undefined) {
        localVarQueryParameter['thumbnail_url'] = thumbnailUrl
      }

      if (album !== undefined) {
        localVarQueryParameter['album'] = album
      }

      if (youtubeDuration !== undefined) {
        localVarQueryParameter['youtube_duration'] = youtubeDuration
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Metadata' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(metadata || {})
        : metadata || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Metadata} [metadata] metadata
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataPost(
      metadata?: Metadata,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/metadata`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Metadata' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(metadata || {})
        : metadata || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataDelete(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDelete(
        id,
        youtubeId,
        youtubeTitle,
        title,
        artist,
        thumbnailUrl,
        album,
        youtubeDuration,
        dateAdded,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataGet(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Metadata>> {
      const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataGet(
        id,
        youtubeId,
        youtubeTitle,
        title,
        artist,
        thumbnailUrl,
        album,
        youtubeDuration,
        dateAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {Metadata} [metadata] metadata
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataPatch(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      metadata?: Metadata,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataPatch(
        id,
        youtubeId,
        youtubeTitle,
        title,
        artist,
        thumbnailUrl,
        album,
        youtubeDuration,
        dateAdded,
        metadata,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {Metadata} [metadata] metadata
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataPost(
      metadata?: Metadata,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataPost(
        metadata,
        select,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataDelete(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return MetadataApiFp(configuration).metadataDelete(
        id,
        youtubeId,
        youtubeTitle,
        title,
        artist,
        thumbnailUrl,
        album,
        youtubeDuration,
        dateAdded,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataGet(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ) {
      return MetadataApiFp(configuration).metadataGet(
        id,
        youtubeId,
        youtubeTitle,
        title,
        artist,
        thumbnailUrl,
        album,
        youtubeDuration,
        dateAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [youtubeId]
     * @param {string} [youtubeTitle]
     * @param {string} [title]
     * @param {string} [artist]
     * @param {string} [thumbnailUrl]
     * @param {string} [album]
     * @param {string} [youtubeDuration]
     * @param {string} [dateAdded]
     * @param {Metadata} [metadata] metadata
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataPatch(
      id?: string,
      youtubeId?: string,
      youtubeTitle?: string,
      title?: string,
      artist?: string,
      thumbnailUrl?: string,
      album?: string,
      youtubeDuration?: string,
      dateAdded?: string,
      metadata?: Metadata,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return MetadataApiFp(configuration).metadataPatch(
        id,
        youtubeId,
        youtubeTitle,
        title,
        artist,
        thumbnailUrl,
        album,
        youtubeDuration,
        dateAdded,
        metadata,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {Metadata} [metadata] metadata
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataPost(
      metadata?: Metadata,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return MetadataApiFp(configuration).metadataPost(
        metadata,
        select,
        prefer,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
  /**
   *
   * @param {string} [id]
   * @param {string} [youtubeId]
   * @param {string} [youtubeTitle]
   * @param {string} [title]
   * @param {string} [artist]
   * @param {string} [thumbnailUrl]
   * @param {string} [album]
   * @param {string} [youtubeDuration]
   * @param {string} [dateAdded]
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetadataApi
   */
  public metadataDelete(
    id?: string,
    youtubeId?: string,
    youtubeTitle?: string,
    title?: string,
    artist?: string,
    thumbnailUrl?: string,
    album?: string,
    youtubeDuration?: string,
    dateAdded?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return MetadataApiFp(this.configuration).metadataDelete(
      id,
      youtubeId,
      youtubeTitle,
      title,
      artist,
      thumbnailUrl,
      album,
      youtubeDuration,
      dateAdded,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [youtubeId]
   * @param {string} [youtubeTitle]
   * @param {string} [title]
   * @param {string} [artist]
   * @param {string} [thumbnailUrl]
   * @param {string} [album]
   * @param {string} [youtubeDuration]
   * @param {string} [dateAdded]
   * @param {string} [select] Filtering Columns
   * @param {string} [order] Ordering
   * @param {string} [range] Limiting and Pagination
   * @param {string} [rangeUnit] Limiting and Pagination
   * @param {string} [offset] Limiting and Pagination
   * @param {string} [limit] Limiting and Pagination
   * @param {'count=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetadataApi
   */
  public metadataGet(
    id?: string,
    youtubeId?: string,
    youtubeTitle?: string,
    title?: string,
    artist?: string,
    thumbnailUrl?: string,
    album?: string,
    youtubeDuration?: string,
    dateAdded?: string,
    select?: string,
    order?: string,
    range?: string,
    rangeUnit?: string,
    offset?: string,
    limit?: string,
    prefer?: 'count=none',
    options?: any
  ) {
    return MetadataApiFp(this.configuration).metadataGet(
      id,
      youtubeId,
      youtubeTitle,
      title,
      artist,
      thumbnailUrl,
      album,
      youtubeDuration,
      dateAdded,
      select,
      order,
      range,
      rangeUnit,
      offset,
      limit,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [youtubeId]
   * @param {string} [youtubeTitle]
   * @param {string} [title]
   * @param {string} [artist]
   * @param {string} [thumbnailUrl]
   * @param {string} [album]
   * @param {string} [youtubeDuration]
   * @param {string} [dateAdded]
   * @param {Metadata} [metadata] metadata
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetadataApi
   */
  public metadataPatch(
    id?: string,
    youtubeId?: string,
    youtubeTitle?: string,
    title?: string,
    artist?: string,
    thumbnailUrl?: string,
    album?: string,
    youtubeDuration?: string,
    dateAdded?: string,
    metadata?: Metadata,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return MetadataApiFp(this.configuration).metadataPatch(
      id,
      youtubeId,
      youtubeTitle,
      title,
      artist,
      thumbnailUrl,
      album,
      youtubeDuration,
      dateAdded,
      metadata,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {Metadata} [metadata] metadata
   * @param {string} [select] Filtering Columns
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetadataApi
   */
  public metadataPost(
    metadata?: Metadata,
    select?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return MetadataApiFp(this.configuration).metadataPost(
      metadata,
      select,
      prefer,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * PlaylistsApi - fetch parameter creator
 * @export
 */
export const PlaylistsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsDelete(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/playlists`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsGet(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/playlists`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (range !== undefined && range !== null) {
        localVarHeaderParameter['Range'] = String(range)
      }

      if (rangeUnit !== undefined && rangeUnit !== null) {
        localVarHeaderParameter['Range-Unit'] = String(rangeUnit)
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {Playlists} [playlists] playlists
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsPatch(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      playlists?: Playlists,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/playlists`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Playlists' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(playlists || {})
        : playlists || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Playlists} [playlists] playlists
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsPost(
      playlists?: Playlists,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/playlists`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Playlists' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(playlists || {})
        : playlists || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsDelete(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = PlaylistsApiFetchParamCreator(configuration).playlistsDelete(
        id,
        name,
        userAdded,
        dateAdded,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsGet(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Playlists>> {
      const localVarFetchArgs = PlaylistsApiFetchParamCreator(configuration).playlistsGet(
        id,
        name,
        userAdded,
        dateAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {Playlists} [playlists] playlists
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsPatch(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      playlists?: Playlists,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = PlaylistsApiFetchParamCreator(configuration).playlistsPatch(
        id,
        name,
        userAdded,
        dateAdded,
        playlists,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {Playlists} [playlists] playlists
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsPost(
      playlists?: Playlists,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = PlaylistsApiFetchParamCreator(configuration).playlistsPost(
        playlists,
        select,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsDelete(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return PlaylistsApiFp(configuration).playlistsDelete(
        id,
        name,
        userAdded,
        dateAdded,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsGet(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ) {
      return PlaylistsApiFp(configuration).playlistsGet(
        id,
        name,
        userAdded,
        dateAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [name]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {Playlists} [playlists] playlists
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsPatch(
      id?: string,
      name?: string,
      userAdded?: string,
      dateAdded?: string,
      playlists?: Playlists,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return PlaylistsApiFp(configuration).playlistsPatch(
        id,
        name,
        userAdded,
        dateAdded,
        playlists,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {Playlists} [playlists] playlists
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playlistsPost(
      playlists?: Playlists,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return PlaylistsApiFp(configuration).playlistsPost(
        playlists,
        select,
        prefer,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
  /**
   *
   * @param {string} [id]
   * @param {string} [name]
   * @param {string} [userAdded]
   * @param {string} [dateAdded]
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlaylistsApi
   */
  public playlistsDelete(
    id?: string,
    name?: string,
    userAdded?: string,
    dateAdded?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return PlaylistsApiFp(this.configuration).playlistsDelete(
      id,
      name,
      userAdded,
      dateAdded,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [name]
   * @param {string} [userAdded]
   * @param {string} [dateAdded]
   * @param {string} [select] Filtering Columns
   * @param {string} [order] Ordering
   * @param {string} [range] Limiting and Pagination
   * @param {string} [rangeUnit] Limiting and Pagination
   * @param {string} [offset] Limiting and Pagination
   * @param {string} [limit] Limiting and Pagination
   * @param {'count=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlaylistsApi
   */
  public playlistsGet(
    id?: string,
    name?: string,
    userAdded?: string,
    dateAdded?: string,
    select?: string,
    order?: string,
    range?: string,
    rangeUnit?: string,
    offset?: string,
    limit?: string,
    prefer?: 'count=none',
    options?: any
  ) {
    return PlaylistsApiFp(this.configuration).playlistsGet(
      id,
      name,
      userAdded,
      dateAdded,
      select,
      order,
      range,
      rangeUnit,
      offset,
      limit,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [name]
   * @param {string} [userAdded]
   * @param {string} [dateAdded]
   * @param {Playlists} [playlists] playlists
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlaylistsApi
   */
  public playlistsPatch(
    id?: string,
    name?: string,
    userAdded?: string,
    dateAdded?: string,
    playlists?: Playlists,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return PlaylistsApiFp(this.configuration).playlistsPatch(
      id,
      name,
      userAdded,
      dateAdded,
      playlists,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {Playlists} [playlists] playlists
   * @param {string} [select] Filtering Columns
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlaylistsApi
   */
  public playlistsPost(
    playlists?: Playlists,
    select?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return PlaylistsApiFp(this.configuration).playlistsPost(
      playlists,
      select,
      prefer,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * SongsApi - fetch parameter creator
 * @export
 */
export const SongsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsDelete(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/songs`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (playlistId !== undefined) {
        localVarQueryParameter['playlist_id'] = playlistId
      }

      if (metadataId !== undefined) {
        localVarQueryParameter['metadata_id'] = metadataId
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsGet(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/songs`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (playlistId !== undefined) {
        localVarQueryParameter['playlist_id'] = playlistId
      }

      if (metadataId !== undefined) {
        localVarQueryParameter['metadata_id'] = metadataId
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (range !== undefined && range !== null) {
        localVarHeaderParameter['Range'] = String(range)
      }

      if (rangeUnit !== undefined && rangeUnit !== null) {
        localVarHeaderParameter['Range-Unit'] = String(rangeUnit)
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {Songs} [songs] songs
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsPatch(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      songs?: Songs,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/songs`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (playlistId !== undefined) {
        localVarQueryParameter['playlist_id'] = playlistId
      }

      if (metadataId !== undefined) {
        localVarQueryParameter['metadata_id'] = metadataId
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Songs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(songs || {}) : songs || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Songs} [songs] songs
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsPost(
      songs?: Songs,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/songs`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Songs' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(songs || {}) : songs || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SongsApi - functional programming interface
 * @export
 */
export const SongsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsDelete(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SongsApiFetchParamCreator(configuration).songsDelete(
        id,
        playlistId,
        metadataId,
        userAdded,
        dateAdded,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsGet(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Songs>> {
      const localVarFetchArgs = SongsApiFetchParamCreator(configuration).songsGet(
        id,
        playlistId,
        metadataId,
        userAdded,
        dateAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {Songs} [songs] songs
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsPatch(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      songs?: Songs,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SongsApiFetchParamCreator(configuration).songsPatch(
        id,
        playlistId,
        metadataId,
        userAdded,
        dateAdded,
        songs,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {Songs} [songs] songs
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsPost(
      songs?: Songs,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SongsApiFetchParamCreator(configuration).songsPost(
        songs,
        select,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * SongsApi - factory interface
 * @export
 */
export const SongsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsDelete(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return SongsApiFp(configuration).songsDelete(
        id,
        playlistId,
        metadataId,
        userAdded,
        dateAdded,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsGet(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ) {
      return SongsApiFp(configuration).songsGet(
        id,
        playlistId,
        metadataId,
        userAdded,
        dateAdded,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [playlistId]
     * @param {string} [metadataId]
     * @param {string} [userAdded]
     * @param {string} [dateAdded]
     * @param {Songs} [songs] songs
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsPatch(
      id?: string,
      playlistId?: string,
      metadataId?: string,
      userAdded?: string,
      dateAdded?: string,
      songs?: Songs,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return SongsApiFp(configuration).songsPatch(
        id,
        playlistId,
        metadataId,
        userAdded,
        dateAdded,
        songs,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {Songs} [songs] songs
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    songsPost(
      songs?: Songs,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return SongsApiFp(configuration).songsPost(songs, select, prefer, options)(fetch, basePath)
    },
  }
}

/**
 * SongsApi - object-oriented interface
 * @export
 * @class SongsApi
 * @extends {BaseAPI}
 */
export class SongsApi extends BaseAPI {
  /**
   *
   * @param {string} [id]
   * @param {string} [playlistId]
   * @param {string} [metadataId]
   * @param {string} [userAdded]
   * @param {string} [dateAdded]
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SongsApi
   */
  public songsDelete(
    id?: string,
    playlistId?: string,
    metadataId?: string,
    userAdded?: string,
    dateAdded?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return SongsApiFp(this.configuration).songsDelete(
      id,
      playlistId,
      metadataId,
      userAdded,
      dateAdded,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [playlistId]
   * @param {string} [metadataId]
   * @param {string} [userAdded]
   * @param {string} [dateAdded]
   * @param {string} [select] Filtering Columns
   * @param {string} [order] Ordering
   * @param {string} [range] Limiting and Pagination
   * @param {string} [rangeUnit] Limiting and Pagination
   * @param {string} [offset] Limiting and Pagination
   * @param {string} [limit] Limiting and Pagination
   * @param {'count=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SongsApi
   */
  public songsGet(
    id?: string,
    playlistId?: string,
    metadataId?: string,
    userAdded?: string,
    dateAdded?: string,
    select?: string,
    order?: string,
    range?: string,
    rangeUnit?: string,
    offset?: string,
    limit?: string,
    prefer?: 'count=none',
    options?: any
  ) {
    return SongsApiFp(this.configuration).songsGet(
      id,
      playlistId,
      metadataId,
      userAdded,
      dateAdded,
      select,
      order,
      range,
      rangeUnit,
      offset,
      limit,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [playlistId]
   * @param {string} [metadataId]
   * @param {string} [userAdded]
   * @param {string} [dateAdded]
   * @param {Songs} [songs] songs
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SongsApi
   */
  public songsPatch(
    id?: string,
    playlistId?: string,
    metadataId?: string,
    userAdded?: string,
    dateAdded?: string,
    songs?: Songs,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return SongsApiFp(this.configuration).songsPatch(
      id,
      playlistId,
      metadataId,
      userAdded,
      dateAdded,
      songs,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {Songs} [songs] songs
   * @param {string} [select] Filtering Columns
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SongsApi
   */
  public songsPost(
    songs?: Songs,
    select?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return SongsApiFp(this.configuration).songsPost(
      songs,
      select,
      prefer,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete(
      id?: string,
      username?: string,
      password?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/users`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(
      id?: string,
      username?: string,
      password?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/users`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (range !== undefined && range !== null) {
        localVarHeaderParameter['Range'] = String(range)
      }

      if (rangeUnit !== undefined && rangeUnit !== null) {
        localVarHeaderParameter['Range-Unit'] = String(rangeUnit)
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {Users} [users] users
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPatch(
      id?: string,
      username?: string,
      password?: string,
      users?: Users,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/users`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Users' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(users || {}) : users || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Users} [users] users
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPost(
      users?: Users,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/users`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Users' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(users || {}) : users || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete(
      id?: string,
      username?: string,
      password?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersDelete(
        id,
        username,
        password,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(
      id?: string,
      username?: string,
      password?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Users>> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersGet(
        id,
        username,
        password,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {Users} [users] users
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPatch(
      id?: string,
      username?: string,
      password?: string,
      users?: Users,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersPatch(
        id,
        username,
        password,
        users,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {Users} [users] users
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPost(
      users?: Users,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersPost(
        users,
        select,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete(
      id?: string,
      username?: string,
      password?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return UsersApiFp(configuration).usersDelete(
        id,
        username,
        password,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(
      id?: string,
      username?: string,
      password?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ) {
      return UsersApiFp(configuration).usersGet(
        id,
        username,
        password,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [username]
     * @param {string} [password]
     * @param {Users} [users] users
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPatch(
      id?: string,
      username?: string,
      password?: string,
      users?: Users,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return UsersApiFp(configuration).usersPatch(
        id,
        username,
        password,
        users,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {Users} [users] users
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPost(
      users?: Users,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return UsersApiFp(configuration).usersPost(users, select, prefer, options)(fetch, basePath)
    },
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @param {string} [id]
   * @param {string} [username]
   * @param {string} [password]
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersDelete(
    id?: string,
    username?: string,
    password?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return UsersApiFp(this.configuration).usersDelete(
      id,
      username,
      password,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [username]
   * @param {string} [password]
   * @param {string} [select] Filtering Columns
   * @param {string} [order] Ordering
   * @param {string} [range] Limiting and Pagination
   * @param {string} [rangeUnit] Limiting and Pagination
   * @param {string} [offset] Limiting and Pagination
   * @param {string} [limit] Limiting and Pagination
   * @param {'count=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersGet(
    id?: string,
    username?: string,
    password?: string,
    select?: string,
    order?: string,
    range?: string,
    rangeUnit?: string,
    offset?: string,
    limit?: string,
    prefer?: 'count=none',
    options?: any
  ) {
    return UsersApiFp(this.configuration).usersGet(
      id,
      username,
      password,
      select,
      order,
      range,
      rangeUnit,
      offset,
      limit,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [username]
   * @param {string} [password]
   * @param {Users} [users] users
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersPatch(
    id?: string,
    username?: string,
    password?: string,
    users?: Users,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return UsersApiFp(this.configuration).usersPatch(
      id,
      username,
      password,
      users,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {Users} [users] users
   * @param {string} [select] Filtering Columns
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersPost(
    users?: Users,
    select?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return UsersApiFp(this.configuration).usersPost(
      users,
      select,
      prefer,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * VotesApi - fetch parameter creator
 * @export
 */
export const VotesApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesDelete(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/votes`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (songId !== undefined) {
        localVarQueryParameter['song_id'] = songId
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesGet(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/votes`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (songId !== undefined) {
        localVarQueryParameter['song_id'] = songId
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (range !== undefined && range !== null) {
        localVarHeaderParameter['Range'] = String(range)
      }

      if (rangeUnit !== undefined && rangeUnit !== null) {
        localVarHeaderParameter['Range-Unit'] = String(rangeUnit)
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {Votes} [votes] votes
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesPatch(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      votes?: Votes,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/votes`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (dateAdded !== undefined) {
        localVarQueryParameter['date_added'] = dateAdded
      }

      if (userAdded !== undefined) {
        localVarQueryParameter['user_added'] = userAdded
      }

      if (songId !== undefined) {
        localVarQueryParameter['song_id'] = songId
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Votes' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(votes || {}) : votes || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Votes} [votes] votes
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesPost(
      votes?: Votes,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/votes`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (select !== undefined) {
        localVarQueryParameter['select'] = select
      }

      if (prefer !== undefined && prefer !== null) {
        localVarHeaderParameter['Prefer'] = String(prefer)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Votes' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(votes || {}) : votes || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VotesApi - functional programming interface
 * @export
 */
export const VotesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesDelete(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VotesApiFetchParamCreator(configuration).votesDelete(
        id,
        dateAdded,
        userAdded,
        songId,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesGet(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Votes>> {
      const localVarFetchArgs = VotesApiFetchParamCreator(configuration).votesGet(
        id,
        dateAdded,
        userAdded,
        songId,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {Votes} [votes] votes
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesPatch(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      votes?: Votes,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VotesApiFetchParamCreator(configuration).votesPatch(
        id,
        dateAdded,
        userAdded,
        songId,
        votes,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {Votes} [votes] votes
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesPost(
      votes?: Votes,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VotesApiFetchParamCreator(configuration).votesPost(
        votes,
        select,
        prefer,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * VotesApi - factory interface
 * @export
 */
export const VotesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesDelete(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return VotesApiFp(configuration).votesDelete(
        id,
        dateAdded,
        userAdded,
        songId,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesGet(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      select?: string,
      order?: string,
      range?: string,
      rangeUnit?: string,
      offset?: string,
      limit?: string,
      prefer?: 'count=none',
      options?: any
    ) {
      return VotesApiFp(configuration).votesGet(
        id,
        dateAdded,
        userAdded,
        songId,
        select,
        order,
        range,
        rangeUnit,
        offset,
        limit,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {string} [id]
     * @param {string} [dateAdded]
     * @param {string} [userAdded]
     * @param {string} [songId]
     * @param {Votes} [votes] votes
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesPatch(
      id?: string,
      dateAdded?: string,
      userAdded?: string,
      songId?: string,
      votes?: Votes,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return VotesApiFp(configuration).votesPatch(
        id,
        dateAdded,
        userAdded,
        songId,
        votes,
        prefer,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {Votes} [votes] votes
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    votesPost(
      votes?: Votes,
      select?: string,
      prefer?: 'return=representation' | 'return=minimal' | 'return=none',
      options?: any
    ) {
      return VotesApiFp(configuration).votesPost(votes, select, prefer, options)(fetch, basePath)
    },
  }
}

/**
 * VotesApi - object-oriented interface
 * @export
 * @class VotesApi
 * @extends {BaseAPI}
 */
export class VotesApi extends BaseAPI {
  /**
   *
   * @param {string} [id]
   * @param {string} [dateAdded]
   * @param {string} [userAdded]
   * @param {string} [songId]
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VotesApi
   */
  public votesDelete(
    id?: string,
    dateAdded?: string,
    userAdded?: string,
    songId?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return VotesApiFp(this.configuration).votesDelete(
      id,
      dateAdded,
      userAdded,
      songId,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [dateAdded]
   * @param {string} [userAdded]
   * @param {string} [songId]
   * @param {string} [select] Filtering Columns
   * @param {string} [order] Ordering
   * @param {string} [range] Limiting and Pagination
   * @param {string} [rangeUnit] Limiting and Pagination
   * @param {string} [offset] Limiting and Pagination
   * @param {string} [limit] Limiting and Pagination
   * @param {'count=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VotesApi
   */
  public votesGet(
    id?: string,
    dateAdded?: string,
    userAdded?: string,
    songId?: string,
    select?: string,
    order?: string,
    range?: string,
    rangeUnit?: string,
    offset?: string,
    limit?: string,
    prefer?: 'count=none',
    options?: any
  ) {
    return VotesApiFp(this.configuration).votesGet(
      id,
      dateAdded,
      userAdded,
      songId,
      select,
      order,
      range,
      rangeUnit,
      offset,
      limit,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {string} [id]
   * @param {string} [dateAdded]
   * @param {string} [userAdded]
   * @param {string} [songId]
   * @param {Votes} [votes] votes
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VotesApi
   */
  public votesPatch(
    id?: string,
    dateAdded?: string,
    userAdded?: string,
    songId?: string,
    votes?: Votes,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return VotesApiFp(this.configuration).votesPatch(
      id,
      dateAdded,
      userAdded,
      songId,
      votes,
      prefer,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {Votes} [votes] votes
   * @param {string} [select] Filtering Columns
   * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VotesApi
   */
  public votesPost(
    votes?: Votes,
    select?: string,
    prefer?: 'return=representation' | 'return=minimal' | 'return=none',
    options?: any
  ) {
    return VotesApiFp(this.configuration).votesPost(
      votes,
      select,
      prefer,
      options
    )(this.fetch, this.basePath)
  }
}
