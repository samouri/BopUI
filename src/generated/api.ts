/**
 * PostgREST API
 * This is a dynamic API generated by PostgREST
 *
 * OpenAPI spec version: 0.4.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

// import * as querystring from 'querystring';
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
const assign = Object.assign;

import { Configuration } from "./configuration";

interface Dictionary<T> {
  [index: string]: T;
}
export interface FetchAPI {
  (url: string, init?: any): Promise<any>;
}

const BASE_PATH = "http://0.0.0.0:3333".replace(/\/+$/, "");

export interface FetchArgs {
  url: string;
  options: any;
}

export class BaseAPI {
  basePath: string;
  fetch: FetchAPI;
  public configuration: Configuration;

  constructor(
    fetch: FetchAPI = isomorphicFetch,
    basePath: string = BASE_PATH,
    configuration: Configuration = new Configuration()
  ) {
    this.basePath = basePath;
    this.fetch = fetch;
    this.configuration = configuration;
  }
}

export interface Metadata {
  id?: number;
  youtube_id?: string;
  youtube_title?: string;
  title?: string;
  artist?: string;
  thumbnail_url?: string;
  album?: string;
  youtube_duration?: string;
  date_added?: string;
}

export interface Playlists {
  id?: number;
  name?: string;
  user_added?: number;
  date_added?: string;
}

export interface Songs {
  id?: number;
  playlist_id?: number;
  metadata_id?: number;
  user_added?: number;
  date_added?: string;
}

export interface Users {
  id?: number;
  username?: string;
  password?: string;
}

export interface Votes {
  id?: number;
  user_added?: number;
  date_added?: string;
  song_id?: number;
}

/**
 * DefaultApi - fetch parameter creator
 */
export const DefaultApiFetchParamCreator = {
  /**
   *
   */
  rootGet(options: any = {}): FetchArgs {
    const baseUrl = `/`;
    let urlObj = url.parse(baseUrl, true);
    let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    if (contentTypeHeader) {
      fetchOptions.headers = assign(
        {},
        contentTypeHeader,
        fetchOptions.headers
      );
    }

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = {
  /**
   *
   */
  rootGet(
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = DefaultApiFetchParamCreator.rootGet(options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   */
  rootGet(options: any = {}) {
    return DefaultApiFp.rootGet(options)(this.fetch, this.basePath);
  }
}

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (fetch?: any, basePath?: string) {
  return {
    /**
     *
     */
    rootGet(options: any = {}) {
      return DefaultApiFp.rootGet(options)(fetch, basePath);
    },
  };
};

/**
 * MetadataApi - fetch parameter creator
 */
export const MetadataApiFetchParamCreator = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataDelete(
    params: {
      prefer?: string;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/metadata`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["youtubeId"] !== undefined) {
      urlObj.query["youtube_id"] = params["youtubeId"];
    }
    if (params["youtubeTitle"] !== undefined) {
      urlObj.query["youtube_title"] = params["youtubeTitle"];
    }
    if (params["title"] !== undefined) {
      urlObj.query["title"] = params["title"];
    }
    if (params["artist"] !== undefined) {
      urlObj.query["artist"] = params["artist"];
    }
    if (params["thumbnailUrl"] !== undefined) {
      urlObj.query["thumbnail_url"] = params["thumbnailUrl"];
    }
    if (params["album"] !== undefined) {
      urlObj.query["album"] = params["album"];
    }
    if (params["youtubeDuration"] !== undefined) {
      urlObj.query["youtube_duration"] = params["youtubeDuration"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/metadata`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["offset"] !== undefined) {
      urlObj.query["offset"] = params["offset"];
    }
    if (params["limit"] !== undefined) {
      urlObj.query["limit"] = params["limit"];
    }
    if (params["select"] !== undefined) {
      urlObj.query["select"] = params["select"];
    }
    if (params["order"] !== undefined) {
      urlObj.query["order"] = params["order"];
    }
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["youtubeId"] !== undefined) {
      urlObj.query["youtube_id"] = params["youtubeId"];
    }
    if (params["youtubeTitle"] !== undefined) {
      urlObj.query["youtube_title"] = params["youtubeTitle"];
    }
    if (params["title"] !== undefined) {
      urlObj.query["title"] = params["title"];
    }
    if (params["artist"] !== undefined) {
      urlObj.query["artist"] = params["artist"];
    }
    if (params["thumbnailUrl"] !== undefined) {
      urlObj.query["thumbnail_url"] = params["thumbnailUrl"];
    }
    if (params["album"] !== undefined) {
      urlObj.query["album"] = params["album"];
    }
    if (params["youtubeDuration"] !== undefined) {
      urlObj.query["youtube_duration"] = params["youtubeDuration"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Range: params["range"],
        "Range-Unit": params["rangeUnit"],
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body metadata
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataPatch(
    params: {
      prefer?: string;
      body?: Metadata;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/metadata`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["youtubeId"] !== undefined) {
      urlObj.query["youtube_id"] = params["youtubeId"];
    }
    if (params["youtubeTitle"] !== undefined) {
      urlObj.query["youtube_title"] = params["youtubeTitle"];
    }
    if (params["title"] !== undefined) {
      urlObj.query["title"] = params["title"];
    }
    if (params["artist"] !== undefined) {
      urlObj.query["artist"] = params["artist"];
    }
    if (params["thumbnailUrl"] !== undefined) {
      urlObj.query["thumbnail_url"] = params["thumbnailUrl"];
    }
    if (params["album"] !== undefined) {
      urlObj.query["album"] = params["album"];
    }
    if (params["youtubeDuration"] !== undefined) {
      urlObj.query["youtube_duration"] = params["youtubeDuration"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body metadata
   */
  metadataPost(
    params: { prefer?: string; body?: Metadata },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/metadata`;
    let urlObj = url.parse(baseUrl, true);
    let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
};

/**
 * MetadataApi - functional programming interface
 */
export const MetadataApiFp = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataDelete(
    params: {
      prefer?: string;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = MetadataApiFetchParamCreator.metadataDelete(
      params,
      options
    );
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      youtube_id?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = MetadataApiFetchParamCreator.metadataGet(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body metadata
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataPatch(
    params: {
      prefer?: string;
      body?: Metadata;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = MetadataApiFetchParamCreator.metadataPatch(
      params,
      options
    );
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body metadata
   */
  metadataPost(
    params: { prefer?: string; body?: Metadata },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = MetadataApiFetchParamCreator.metadataPost(
      params,
      options
    );
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
};

/**
 * MetadataApi - object-oriented interface
 */
export class MetadataApi extends BaseAPI {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataDelete(
    params: {
      prefer?: string;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return MetadataApiFp.metadataDelete(params, options)(
      this.fetch,
      this.basePath
    );
  }
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return MetadataApiFp.metadataGet(params, options)(
      this.fetch,
      this.basePath
    );
  }
  /**
   *
   * @param prefer Preference
   * @param body metadata
   * @param id
   * @param youtubeId
   * @param youtubeTitle
   * @param title
   * @param artist
   * @param thumbnailUrl
   * @param album
   * @param youtubeDuration
   * @param dateAdded
   */
  metadataPatch(
    params: {
      prefer?: string;
      body?: Metadata;
      id?: string;
      youtubeId?: string;
      youtubeTitle?: string;
      title?: string;
      artist?: string;
      thumbnailUrl?: string;
      album?: string;
      youtubeDuration?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return MetadataApiFp.metadataPatch(params, options)(
      this.fetch,
      this.basePath
    );
  }
  /**
   *
   * @param prefer Preference
   * @param body metadata
   */
  metadataPost(
    params: { prefer?: string; body?: Metadata },
    options: any = {}
  ) {
    return MetadataApiFp.metadataPost(params, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * MetadataApi - factory interface
 */
export const MetadataApiFactory = function (fetch?: any, basePath?: string) {
  return {
    /**
     *
     * @param prefer Preference
     * @param id
     * @param youtubeId
     * @param youtubeTitle
     * @param title
     * @param artist
     * @param thumbnailUrl
     * @param album
     * @param youtubeDuration
     * @param dateAdded
     */
    metadataDelete(
      params: {
        prefer?: string;
        id?: string;
        youtubeId?: string;
        youtubeTitle?: string;
        title?: string;
        artist?: string;
        thumbnailUrl?: string;
        album?: string;
        youtubeDuration?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return MetadataApiFp.metadataDelete(params, options)(fetch, basePath);
    },
    /**
     *
     * @param range Limiting and Pagination
     * @param rangeUnit Limiting and Pagination
     * @param offset Limiting and Pagination
     * @param limit Limiting and Pagination
     * @param select Filtering Columns
     * @param order Ordering
     * @param prefer Preference
     * @param id
     * @param youtubeId
     * @param youtubeTitle
     * @param title
     * @param artist
     * @param thumbnailUrl
     * @param album
     * @param youtubeDuration
     * @param dateAdded
     */
    metadataGet(
      params: {
        range?: string;
        rangeUnit?: string;
        offset?: string;
        limit?: string;
        select?: string;
        order?: string;
        prefer?: string;
        id?: string;
        youtubeId?: string;
        youtubeTitle?: string;
        title?: string;
        artist?: string;
        thumbnailUrl?: string;
        album?: string;
        youtubeDuration?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return MetadataApiFp.metadataGet(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body metadata
     * @param id
     * @param youtubeId
     * @param youtubeTitle
     * @param title
     * @param artist
     * @param thumbnailUrl
     * @param album
     * @param youtubeDuration
     * @param dateAdded
     */
    metadataPatch(
      params: {
        prefer?: string;
        body?: Metadata;
        id?: string;
        youtubeId?: string;
        youtubeTitle?: string;
        title?: string;
        artist?: string;
        thumbnailUrl?: string;
        album?: string;
        youtubeDuration?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return MetadataApiFp.metadataPatch(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body metadata
     */
    metadataPost(
      params: { prefer?: string; body?: Metadata },
      options: any = {}
    ) {
      return MetadataApiFp.metadataPost(params, options)(fetch, basePath);
    },
  };
};

/**
 * PlaylistsApi - fetch parameter creator
 */
export const PlaylistsApiFetchParamCreator = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsDelete(
    params: {
      prefer?: string;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/playlists`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["name"] !== undefined) {
      urlObj.query["name"] = params["name"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/playlists`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["offset"] !== undefined) {
      urlObj.query["offset"] = params["offset"];
    }
    if (params["limit"] !== undefined) {
      urlObj.query["limit"] = params["limit"];
    }
    if (params["select"] !== undefined) {
      urlObj.query["select"] = params["select"];
    }
    if (params["order"] !== undefined) {
      urlObj.query["order"] = params["order"];
    }
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["name"] !== undefined) {
      urlObj.query["name"] = params["name"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Range: params["range"],
        "Range-Unit": params["rangeUnit"],
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body playlists
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsPatch(
    params: {
      prefer?: string;
      body?: Playlists;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/playlists`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["name"] !== undefined) {
      urlObj.query["name"] = params["name"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body playlists
   */
  playlistsPost(
    params: { prefer?: string; body?: Playlists },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/playlists`;
    let urlObj = url.parse(baseUrl, true);
    let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
};

/**
 * PlaylistsApi - functional programming interface
 */
export const PlaylistsApiFp = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsDelete(
    params: {
      prefer?: string;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = PlaylistsApiFetchParamCreator.playlistsDelete(
      params,
      options
    );
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = PlaylistsApiFetchParamCreator.playlistsGet(
      params,
      options
    );
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body playlists
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsPatch(
    params: {
      prefer?: string;
      body?: Playlists;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = PlaylistsApiFetchParamCreator.playlistsPatch(
      params,
      options
    );
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body playlists
   */
  playlistsPost(
    params: { prefer?: string; body?: Playlists },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = PlaylistsApiFetchParamCreator.playlistsPost(
      params,
      options
    );
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
};

/**
 * PlaylistsApi - object-oriented interface
 */
export class PlaylistsApi extends BaseAPI {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsDelete(
    params: {
      prefer?: string;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return PlaylistsApiFp.playlistsDelete(params, options)(
      this.fetch,
      this.basePath
    );
  }
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return PlaylistsApiFp.playlistsGet(params, options)(
      this.fetch,
      this.basePath
    );
  }
  /**
   *
   * @param prefer Preference
   * @param body playlists
   * @param id
   * @param name
   * @param userAdded
   * @param dateAdded
   */
  playlistsPatch(
    params: {
      prefer?: string;
      body?: Playlists;
      id?: string;
      name?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return PlaylistsApiFp.playlistsPatch(params, options)(
      this.fetch,
      this.basePath
    );
  }
  /**
   *
   * @param prefer Preference
   * @param body playlists
   */
  playlistsPost(
    params: { prefer?: string; body?: Playlists },
    options: any = {}
  ) {
    return PlaylistsApiFp.playlistsPost(params, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * PlaylistsApi - factory interface
 */
export const PlaylistsApiFactory = function (fetch?: any, basePath?: string) {
  return {
    /**
     *
     * @param prefer Preference
     * @param id
     * @param name
     * @param userAdded
     * @param dateAdded
     */
    playlistsDelete(
      params: {
        prefer?: string;
        id?: string;
        name?: string;
        userAdded?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return PlaylistsApiFp.playlistsDelete(params, options)(fetch, basePath);
    },
    /**
     *
     * @param range Limiting and Pagination
     * @param rangeUnit Limiting and Pagination
     * @param offset Limiting and Pagination
     * @param limit Limiting and Pagination
     * @param select Filtering Columns
     * @param order Ordering
     * @param prefer Preference
     * @param id
     * @param name
     * @param userAdded
     * @param dateAdded
     */
    playlistsGet(
      params: {
        range?: string;
        rangeUnit?: string;
        offset?: string;
        limit?: string;
        select?: string;
        order?: string;
        prefer?: string;
        id?: string;
        name?: string;
        userAdded?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return PlaylistsApiFp.playlistsGet(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body playlists
     * @param id
     * @param name
     * @param userAdded
     * @param dateAdded
     */
    playlistsPatch(
      params: {
        prefer?: string;
        body?: Playlists;
        id?: string;
        name?: string;
        userAdded?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return PlaylistsApiFp.playlistsPatch(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body playlists
     */
    playlistsPost(
      params: { prefer?: string; body?: Playlists },
      options: any = {}
    ) {
      return PlaylistsApiFp.playlistsPost(params, options)(fetch, basePath);
    },
  };
};

/**
 * SongsApi - fetch parameter creator
 */
export const SongsApiFetchParamCreator = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsDelete(
    params: {
      prefer?: string;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/songs`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["playlistId"] !== undefined) {
      urlObj.query["playlist_id"] = params["playlistId"];
    }
    if (params["metadataId"] !== undefined) {
      urlObj.query["metadata_id"] = params["metadataId"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/songs`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["offset"] !== undefined) {
      urlObj.query["offset"] = params["offset"];
    }
    if (params["limit"] !== undefined) {
      urlObj.query["limit"] = params["limit"];
    }
    if (params["select"] !== undefined) {
      urlObj.query["select"] = params["select"];
    }
    if (params["order"] !== undefined) {
      urlObj.query["order"] = params["order"];
    }
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["playlistId"] !== undefined) {
      urlObj.query["playlist_id"] = params["playlistId"];
    }
    if (params["metadataId"] !== undefined) {
      urlObj.query["metadata_id"] = params["metadataId"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Range: params["range"],
        "Range-Unit": params["rangeUnit"],
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body songs
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsPatch(
    params: {
      prefer?: string;
      body?: Songs;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/songs`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["playlistId"] !== undefined) {
      urlObj.query["playlist_id"] = params["playlistId"];
    }
    if (params["metadataId"] !== undefined) {
      urlObj.query["metadata_id"] = params["metadataId"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body songs
   */
  songsPost(
    params: { prefer?: string; body?: Songs },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/songs`;
    let urlObj = url.parse(baseUrl, true);
    let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
};

/**
 * SongsApi - functional programming interface
 */
export const SongsApiFp = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsDelete(
    params: {
      prefer?: string;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = SongsApiFetchParamCreator.songsDelete(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = SongsApiFetchParamCreator.songsGet(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body songs
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsPatch(
    params: {
      prefer?: string;
      body?: Songs;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = SongsApiFetchParamCreator.songsPatch(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body songs
   */
  songsPost(
    params: { prefer?: string; body?: Songs },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = SongsApiFetchParamCreator.songsPost(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
};

/**
 * SongsApi - object-oriented interface
 */
export class SongsApi extends BaseAPI {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsDelete(
    params: {
      prefer?: string;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return SongsApiFp.songsDelete(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return SongsApiFp.songsGet(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param prefer Preference
   * @param body songs
   * @param id
   * @param playlistId
   * @param metadataId
   * @param userAdded
   * @param dateAdded
   */
  songsPatch(
    params: {
      prefer?: string;
      body?: Songs;
      id?: string;
      playlistId?: string;
      metadataId?: string;
      userAdded?: string;
      dateAdded?: string;
    },
    options: any = {}
  ) {
    return SongsApiFp.songsPatch(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param prefer Preference
   * @param body songs
   */
  songsPost(params: { prefer?: string; body?: Songs }, options: any = {}) {
    return SongsApiFp.songsPost(params, options)(this.fetch, this.basePath);
  }
}

/**
 * SongsApi - factory interface
 */
export const SongsApiFactory = function (fetch?: any, basePath?: string) {
  return {
    /**
     *
     * @param prefer Preference
     * @param id
     * @param playlistId
     * @param metadataId
     * @param userAdded
     * @param dateAdded
     */
    songsDelete(
      params: {
        prefer?: string;
        id?: string;
        playlistId?: string;
        metadataId?: string;
        userAdded?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return SongsApiFp.songsDelete(params, options)(fetch, basePath);
    },
    /**
     *
     * @param range Limiting and Pagination
     * @param rangeUnit Limiting and Pagination
     * @param offset Limiting and Pagination
     * @param limit Limiting and Pagination
     * @param select Filtering Columns
     * @param order Ordering
     * @param prefer Preference
     * @param id
     * @param playlistId
     * @param metadataId
     * @param userAdded
     * @param dateAdded
     */
    songsGet(
      params: {
        range?: string;
        rangeUnit?: string;
        offset?: string;
        limit?: string;
        select?: string;
        order?: string;
        prefer?: string;
        id?: string;
        playlistId?: string;
        metadataId?: string;
        userAdded?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return SongsApiFp.songsGet(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body songs
     * @param id
     * @param playlistId
     * @param metadataId
     * @param userAdded
     * @param dateAdded
     */
    songsPatch(
      params: {
        prefer?: string;
        body?: Songs;
        id?: string;
        playlistId?: string;
        metadataId?: string;
        userAdded?: string;
        dateAdded?: string;
      },
      options: any = {}
    ) {
      return SongsApiFp.songsPatch(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body songs
     */
    songsPost(params: { prefer?: string; body?: Songs }, options: any = {}) {
      return SongsApiFp.songsPost(params, options)(fetch, basePath);
    },
  };
};

/**
 * UsersApi - fetch parameter creator
 */
export const UsersApiFetchParamCreator = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param username
   * @param password
   */
  usersDelete(
    params: {
      prefer?: string;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/users`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["username"] !== undefined) {
      urlObj.query["username"] = params["username"];
    }
    if (params["password"] !== undefined) {
      urlObj.query["password"] = params["password"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param username
   * @param password
   */
  usersGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/users`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["offset"] !== undefined) {
      urlObj.query["offset"] = params["offset"];
    }
    if (params["limit"] !== undefined) {
      urlObj.query["limit"] = params["limit"];
    }
    if (params["select"] !== undefined) {
      urlObj.query["select"] = params["select"];
    }
    if (params["order"] !== undefined) {
      urlObj.query["order"] = params["order"];
    }
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["username"] !== undefined) {
      urlObj.query["username"] = params["username"];
    }
    if (params["password"] !== undefined) {
      urlObj.query["password"] = params["password"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Range: params["range"],
        "Range-Unit": params["rangeUnit"],
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body users
   * @param id
   * @param username
   * @param password
   */
  usersPatch(
    params: {
      prefer?: string;
      body?: Users;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/users`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["username"] !== undefined) {
      urlObj.query["username"] = params["username"];
    }
    if (params["password"] !== undefined) {
      urlObj.query["password"] = params["password"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body users
   */
  usersPost(
    params: { prefer?: string; body?: Users },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/users`;
    let urlObj = url.parse(baseUrl, true);
    let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param username
   * @param password
   */
  usersDelete(
    params: {
      prefer?: string;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = UsersApiFetchParamCreator.usersDelete(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param username
   * @param password
   */
  usersGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = UsersApiFetchParamCreator.usersGet(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body users
   * @param id
   * @param username
   * @param password
   */
  usersPatch(
    params: {
      prefer?: string;
      body?: Users;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = UsersApiFetchParamCreator.usersPatch(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body users
   */
  usersPost(
    params: { prefer?: string; body?: Users },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = UsersApiFetchParamCreator.usersPost(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param username
   * @param password
   */
  usersDelete(
    params: {
      prefer?: string;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ) {
    return UsersApiFp.usersDelete(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param username
   * @param password
   */
  usersGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ) {
    return UsersApiFp.usersGet(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param prefer Preference
   * @param body users
   * @param id
   * @param username
   * @param password
   */
  usersPatch(
    params: {
      prefer?: string;
      body?: Users;
      id?: string;
      username?: string;
      password?: string;
    },
    options: any = {}
  ) {
    return UsersApiFp.usersPatch(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param prefer Preference
   * @param body users
   */
  usersPost(params: { prefer?: string; body?: Users }, options: any = {}) {
    return UsersApiFp.usersPost(params, options)(this.fetch, this.basePath);
  }
}

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (fetch?: any, basePath?: string) {
  return {
    /**
     *
     * @param prefer Preference
     * @param id
     * @param username
     * @param password
     */
    usersDelete(
      params: {
        prefer?: string;
        id?: string;
        username?: string;
        password?: string;
      },
      options: any = {}
    ) {
      return UsersApiFp.usersDelete(params, options)(fetch, basePath);
    },
    /**
     *
     * @param range Limiting and Pagination
     * @param rangeUnit Limiting and Pagination
     * @param offset Limiting and Pagination
     * @param limit Limiting and Pagination
     * @param select Filtering Columns
     * @param order Ordering
     * @param prefer Preference
     * @param id
     * @param username
     * @param password
     */
    usersGet(
      params: {
        range?: string;
        rangeUnit?: string;
        offset?: string;
        limit?: string;
        select?: string;
        order?: string;
        prefer?: string;
        id?: string;
        username?: string;
        password?: string;
      },
      options: any = {}
    ) {
      return UsersApiFp.usersGet(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body users
     * @param id
     * @param username
     * @param password
     */
    usersPatch(
      params: {
        prefer?: string;
        body?: Users;
        id?: string;
        username?: string;
        password?: string;
      },
      options: any = {}
    ) {
      return UsersApiFp.usersPatch(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body users
     */
    usersPost(params: { prefer?: string; body?: Users }, options: any = {}) {
      return UsersApiFp.usersPost(params, options)(fetch, basePath);
    },
  };
};

/**
 * VotesApi - fetch parameter creator
 */
export const VotesApiFetchParamCreator = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesDelete(
    params: {
      prefer?: string;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/votes`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["songId"] !== undefined) {
      urlObj.query["song_id"] = params["songId"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/votes`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["offset"] !== undefined) {
      urlObj.query["offset"] = params["offset"];
    }
    if (params["limit"] !== undefined) {
      urlObj.query["limit"] = params["limit"];
    }
    if (params["select"] !== undefined) {
      urlObj.query["select"] = params["select"];
    }
    if (params["order"] !== undefined) {
      urlObj.query["order"] = params["order"];
    }
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["songId"] !== undefined) {
      urlObj.query["song_id"] = params["songId"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    fetchOptions.headers = assign(
      {
        Range: params["range"],
        "Range-Unit": params["rangeUnit"],
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body votes
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesPatch(
    params: {
      prefer?: string;
      body?: Votes;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/votes`;
    let urlObj = url.parse(baseUrl, true);
    urlObj.query = assign({}, urlObj.query);
    if (params["id"] !== undefined) {
      urlObj.query["id"] = params["id"];
    }
    if (params["dateAdded"] !== undefined) {
      urlObj.query["date_added"] = params["dateAdded"];
    }
    if (params["userAdded"] !== undefined) {
      urlObj.query["user_added"] = params["userAdded"];
    }
    if (params["songId"] !== undefined) {
      urlObj.query["song_id"] = params["songId"];
    }
    let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body votes
   */
  votesPost(
    params: { prefer?: string; body?: Votes },
    options: any = {}
  ): FetchArgs {
    const baseUrl = `/votes`;
    let urlObj = url.parse(baseUrl, true);
    let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

    let contentTypeHeader: Dictionary<string> = {};
    contentTypeHeader = { "Content-Type": "application/json" };
    if (params["body"]) {
      fetchOptions.body = JSON.stringify(params["body"] || {});
    }
    fetchOptions.headers = assign(
      {
        Prefer: params["prefer"],
      },
      contentTypeHeader,
      fetchOptions.headers
    );

    return {
      url: url.format(urlObj),
      options: fetchOptions,
    };
  },
};

/**
 * VotesApi - functional programming interface
 */
export const VotesApiFp = {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesDelete(
    params: {
      prefer?: string;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = VotesApiFetchParamCreator.votesDelete(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = VotesApiFetchParamCreator.votesGet(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body votes
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesPatch(
    params: {
      prefer?: string;
      body?: Votes;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = VotesApiFetchParamCreator.votesPatch(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
  /**
   *
   * @param prefer Preference
   * @param body votes
   */
  votesPost(
    params: { prefer?: string; body?: Votes },
    options: any = {}
  ): (fetch: FetchAPI, basePath?: string) => Promise<any> {
    const fetchArgs = VotesApiFetchParamCreator.votesPost(params, options);
    return (
      fetch: FetchAPI = isomorphicFetch,
      basePath: string = BASE_PATH
    ) => {
      return fetch(basePath + fetchArgs.url, fetchArgs.options).then(
        (response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        }
      );
    };
  },
};

/**
 * VotesApi - object-oriented interface
 */
export class VotesApi extends BaseAPI {
  /**
   *
   * @param prefer Preference
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesDelete(
    params: {
      prefer?: string;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ) {
    return VotesApiFp.votesDelete(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param range Limiting and Pagination
   * @param rangeUnit Limiting and Pagination
   * @param offset Limiting and Pagination
   * @param limit Limiting and Pagination
   * @param select Filtering Columns
   * @param order Ordering
   * @param prefer Preference
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesGet(
    params: {
      range?: string;
      rangeUnit?: string;
      offset?: string;
      limit?: string;
      select?: string;
      order?: string;
      prefer?: string;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ) {
    return VotesApiFp.votesGet(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param prefer Preference
   * @param body votes
   * @param id
   * @param dateAdded
   * @param userAdded
   * @param songId
   */
  votesPatch(
    params: {
      prefer?: string;
      body?: Votes;
      id?: string;
      dateAdded?: string;
      userAdded?: string;
      songId?: string;
    },
    options: any = {}
  ) {
    return VotesApiFp.votesPatch(params, options)(this.fetch, this.basePath);
  }
  /**
   *
   * @param prefer Preference
   * @param body votes
   */
  votesPost(params: { prefer?: string; body?: Votes }, options: any = {}) {
    return VotesApiFp.votesPost(params, options)(this.fetch, this.basePath);
  }
}

/**
 * VotesApi - factory interface
 */
export const VotesApiFactory = function (fetch?: any, basePath?: string) {
  return {
    /**
     *
     * @param prefer Preference
     * @param id
     * @param dateAdded
     * @param userAdded
     * @param songId
     */
    votesDelete(
      params: {
        prefer?: string;
        id?: string;
        dateAdded?: string;
        userAdded?: string;
        songId?: string;
      },
      options: any = {}
    ) {
      return VotesApiFp.votesDelete(params, options)(fetch, basePath);
    },
    /**
     *
     * @param range Limiting and Pagination
     * @param rangeUnit Limiting and Pagination
     * @param offset Limiting and Pagination
     * @param limit Limiting and Pagination
     * @param select Filtering Columns
     * @param order Ordering
     * @param prefer Preference
     * @param id
     * @param dateAdded
     * @param userAdded
     * @param songId
     */
    votesGet(
      params: {
        range?: string;
        rangeUnit?: string;
        offset?: string;
        limit?: string;
        select?: string;
        order?: string;
        prefer?: string;
        id?: string;
        dateAdded?: string;
        userAdded?: string;
        songId?: string;
      },
      options: any = {}
    ) {
      return VotesApiFp.votesGet(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body votes
     * @param id
     * @param dateAdded
     * @param userAdded
     * @param songId
     */
    votesPatch(
      params: {
        prefer?: string;
        body?: Votes;
        id?: string;
        dateAdded?: string;
        userAdded?: string;
        songId?: string;
      },
      options: any = {}
    ) {
      return VotesApiFp.votesPatch(params, options)(fetch, basePath);
    },
    /**
     *
     * @param prefer Preference
     * @param body votes
     */
    votesPost(params: { prefer?: string; body?: Votes }, options: any = {}) {
      return VotesApiFp.votesPost(params, options)(fetch, basePath);
    },
  };
};
